<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Real-time Crypto Prices — BTC / ETH / DOGE</title>
  <style>
    :root{
      --bg:#0f1724; --card:#0b1220; --muted:#9aa4b2; --accent:#60a5fa;
      --glass: rgba(255,255,255,0.03);
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      min-height:100vh;
      display:flex;
      align-items:center;
      justify-content:center;
      background: linear-gradient(180deg,#071028 0%, #071830 100%);
      color:#e6eef6;
      padding:24px;
    }
    .app{
      width:100%;
      max-width:960px;
    }
    header{display:flex;align-items:center;justify-content:space-between;margin-bottom:18px}
    h1{font-size:1.25rem;margin:0}
    .controls{display:flex;gap:8px;align-items:center}
    .chip{
      background:var(--glass);
      padding:6px 10px;border-radius:999px;font-size:0.9rem;color:var(--muted);
      display:inline-flex;gap:8px;align-items:center;
    }
    .grid{
      display:grid;
      grid-template-columns:repeat(auto-fit,minmax(220px,1fr));
      gap:14px;
    }
    .card{
      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.05));
      border:1px solid rgba(255,255,255,0.03);
      border-radius:12px;padding:16px;
      box-shadow: 0 6px 18px rgba(2,6,23,0.6);
      min-height:110px;
    }
    .symbol{display:flex;align-items:center;gap:12px}
    .icon{
      width:44px;height:44px;border-radius:10px;background:#07122a;display:inline-flex;
      align-items:center;justify-content:center;font-weight:700;font-size:1rem;color:var(--accent);
      border:1px solid rgba(255,255,255,0.03)
    }
    .price{font-size:1.35rem;margin-top:10px;letter-spacing:0.2px}
    .meta{margin-top:8px;color:var(--muted);font-size:0.9rem}
    .muted{color:var(--muted)}
    .status{padding:6px 10px;border-radius:8px;background:rgba(255,255,255,0.02);font-size:0.9rem}
    .btn{
      background:transparent;border:1px solid rgba(255,255,255,0.04);color:var(--muted);padding:8px 12px;border-radius:8px;cursor:pointer;
    }
    .small{font-size:0.86rem}
    footer{margin-top:14px;color:var(--muted);font-size:0.85rem}
    @media (max-width:560px){ .symbol .icon{width:40px;height:40px} .price{font-size:1.1rem} }
  </style>
</head>
<body>
  <div class="app" role="main">
    <header>
      <h1>Crypto Prices — BTC · ETH · DOGE</h1>
      <div class="controls">
        <div class="chip" id="connStatus">Connecting…</div>
        <button class="btn" id="toggleMode">Use fallback polling</button>
      </div>
    </header>

    <section class="grid" aria-live="polite" id="cards">
      <!-- Cards inserted by JS -->
    </section>

    <footer>
      <div class="muted small">Data sources: Binance WebSocket (primary) • CoinGecko (fallback polling) — no API key required.</div>
    </footer>
  </div>

  <script>
    // --- Configuration ---
    const symbols = [
      {id:'bitcoin', label:'BTC', wsSymbol:'btcusdt', cgId:'bitcoin'},
      {id:'ethereum', label:'ETH', wsSymbol:'ethusdt', cgId:'ethereum'},
      {id:'dogecoin', label:'DOGE', wsSymbol:'dogeusdt', cgId:'dogecoin'}
    ];
    const BINANCE_WS_BASE = 'wss://stream.binance.com:9443/ws/';
    const COINGECKO_PRICE_API = 'https://api.coingecko.com/api/v3/simple/price';
    const POLL_INTERVAL_MS = 8_000; // fallback polling interval

    // --- DOM helpers ---
    const cardsContainer = document.getElementById('cards');
    const connStatus = document.getElementById('connStatus');
    const toggleBtn = document.getElementById('toggleMode');
    let useFallback = false;

    // Create UI cards
    const state = {}; // store current prices, etc.
    symbols.forEach(s => {
      state[s.label] = {price:null, time:null, change24h:null};
      const card = document.createElement('div');
      card.className = 'card';
      card.id = 'card-' + s.label;
      card.innerHTML = `
        <div class="symbol">
          <div class="icon">${s.label}</div>
          <div>
            <div style="font-weight:700">${s.label}</div>
            <div class="muted small">${s.id}</div>
          </div>
        </div>
        <div class="price" id="price-${s.label}">—</div>
        <div class="meta">
          <span id="change-${s.label}" class="muted">24h: —</span>
          &nbsp;•&nbsp;
          <span id="time-${s.label}" class="muted small">updated: —</span>
        </div>
      `;
      cardsContainer.appendChild(card);
    });

    // Format function
    function fmtPrice(p, label){
      if (label === 'DOGE') return Number(p).toFixed(4);
      if (p >= 1000) return Number(p).toLocaleString(undefined, {maximumFractionDigits:2});
      return Number(p).toFixed(2);
    }
    function fmtTime(ts){ return new Date(ts).toLocaleTimeString(); }

    // Update UI
    function updateUI(label, price, time, change24h){
      const priceEl = document.getElementById('price-' + label);
      const timeEl = document.getElementById('time-' + label);
      const changeEl = document.getElementById('change-' + label);
      if (price !== undefined && price !== null){
        priceEl.textContent = '$' + fmtPrice(price, label);
      }
      if (time) timeEl.textContent = 'updated: ' + fmtTime(time);
      if (change24h !== undefined && change24h !== null){
        const sign = change24h >= 0 ? '+' : '';
        changeEl.textContent = `24h: ${sign}${change24h.toFixed(2)}%`;
        changeEl.style.color = change24h >= 0 ? '#4ade80' : '#fb7185';
      }
    }

    // --- CoinGecko fallback poller ---
    let poller = null;
    async function pollCoinGecko(){
      try {
        const ids = symbols.map(s => s.cgId).join(',');
        const resp = await fetch(`${COINGECKO_PRICE_API}?ids=${ids}&vs_currencies=usd&include_24hr_change=true`);
        if (!resp.ok) throw new Error('CG API ' + resp.status);
        const data = await resp.json();
        const now = Date.now();
        symbols.forEach(s => {
          const price = data[s.cgId]?.usd ?? null;
          const change = data[s.cgId]?.usd_24h_change ?? null;
          if (price !== null) {
            state[s.label].price = price;
            state[s.label].time = now;
            state[s.label].change24h = change;
            updateUI(s.label, price, now, change);
          }
        });
        connStatus.textContent = 'Fallback: CoinGecko polling';
      } catch (err) {
        console.warn('CoinGecko poll error', err);
        connStatus.textContent = 'Fallback polling failed';
      }
    }

    // --- Binance WebSockets (primary) ---
    const sockets = {};
    let reconnectAttempts = 0;
    function startSockets(){
      reconnectAttempts = 0;
      connStatus.textContent = 'Connecting (Binance WS)…';
      symbols.forEach(s => openSocketFor(s));
    }

    function openSocketFor(s){
      const wsUrl = BINANCE_WS_BASE + s.wsSymbol + '@trade';
      try {
        const ws = new WebSocket(wsUrl);
        sockets[s.label] = ws;

        ws.addEventListener('open', () => {
          reconnectAttempts = 0;
          connStatus.textContent = 'Connected (Binance WS)';
          toggleBtn.textContent = 'Force fallback polling';
        });

        ws.addEventListener('message', msg => {
          // Binance trade message has fields including 'p' = price, 'T' event time
          try {
            const data = JSON.parse(msg.data);
            const price = parseFloat(data.p);
            const ts = data.T || Date.now();
            // update state and UI
            state[s.label].price = price;
            state[s.label].time = ts;
            updateUI(s.label, price, ts, state[s.label].change24h); // change24h may be null
          } catch(e){
            console.warn('WS parse error for', s.label, e);
          }
        });

        ws.addEventListener('close', (ev) => {
          console.warn('WS closed', s.label, ev);
          connStatus.textContent = 'WS connection closed — switching to fallback soon';
          // try reconnect after delay
          attemptReconnect(s);
        });

        ws.addEventListener('error', (err) => {
          console.error('WS error', s.label, err);
          connStatus.textContent = 'WS error — using fallback';
          try { ws.close(); } catch(e){}
          attemptReconnect(s);
        });
      } catch(err){
        console.error('openSocketFor error', err);
        connStatus.textContent = 'WS failed to start';
        attemptReconnect(s);
      }
    }

    function attemptReconnect(s){
      reconnectAttempts++;
      const delay = Math.min(30_000, 1000 * Math.pow(2, Math.min(6, reconnectAttempts))); // exp backoff
      setTimeout(() => {
        // If user switched to fallback, don't reconnect
        if (useFallback) return;
        openSocketFor(s);
      }, delay);
      // also start fallback poller if not already
      enableFallback();
    }

    // --- Fallback control ---
    function enableFallback(){
      if (!poller){
        pollCoinGecko(); // immediate
        poller = setInterval(pollCoinGecko, POLL_INTERVAL_MS);
      }
      useFallback = true;
      toggleBtn.textContent = 'Use Binance WS (recommended)';
      connStatus.textContent = 'Using fallback polling (CoinGecko)';
      // close websockets if open
      Object.values(sockets).forEach(ws => {
        try{ ws.close(); } catch(e){}
      });
    }
    function disableFallback(){
      if (poller){ clearInterval(poller); poller = null; }
      useFallback = false;
      toggleBtn.textContent = 'Force fallback polling';
      connStatus.textContent = 'Starting Binance WS…';
      startSockets();
    }

    // Toggle button
    toggleBtn.addEventListener('click', () => {
      if (useFallback) disableFallback();
      else enableFallback();
    });

    // initial fetch to populate 24h change (and price until WS arrives)
    (async function initialFill(){
      try {
        // get 24h changes + initial prices from CoinGecko
        await pollCoinGecko();
        // then start WS
        if (!useFallback) startSockets();
      } catch(e){
        console.warn('initialFill error', e);
        enableFallback();
      }
    })();

    // small heartbeat to detect if all WS are closed / not receiving updates for a while
    setInterval(() => {
      if (useFallback) return;
      // if every symbol has null price for >10s, switch to fallback
      const now = Date.now();
      let noRecent = 0;
      symbols.forEach(s => {
        const st = state[s.label].time || 0;
        if ((now - st) > 15_000) noRecent++;
      });
      if (noRecent === symbols.length) {
        console.warn('No recent WS updates, enabling fallback.');
        enableFallback();
      }
    }, 7_000);

    // Expose for debugging (optional)
    window.__cryptoApp = {state, enableFallback, disableFallback};

  </script>
</body>
</html>
